# -*- coding: utf-8 -*-
"""
/***************************************************************************
 RSDlTool
                                 A QGIS plugin
 This is Plugin use DL in Rs
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-08-31
        git sha              : $Format:%H$
        copyright            : (C) 2022 by libin
        email                : ts20160039a31@edu.cumt.cn
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os.path
from typing import Optional, List
# Initialize Qt resources from file resources.py
from PyQt5.QtWidgets import (
    QMessageBox, QFileDialog, QAction
)

from PyQt5.QtCore import QThread
from omegaconf import OmegaConf
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.gui import QgsFileWidget
from qgis.core import (
    QgsProject, QgsVectorLayer, QgsMapLayer, QgsRasterLayer, QgsMapLayerType, Qgis
)
import processing

from .workers import SplittingCreator
from .RsDlTool_dialog import RSDlToolDialog
from . import config
import tempfile
from .utils import *
from .resources import *


class RSDlTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.plugin_name = 'RSDLTOOL'

        self.temp_dir = tempfile.gettempdir()
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'RSDlTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.toolbar = self.iface.addToolBar(config.PLUGIN_NAME)
        self.toolbar.setObjectName(config.PLUGIN_NAME)
        self.menu = self.tr(u'&Rs DL Tool')
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    def valid_exist_layer(self, path):
        # rlayer = self.project.mapLayersByName(os.path.splitext(os.path.basename(path))[0])
        # if len(rlayer) > 0:
        #     return rlayer[0]
        # else:
        return None

    def select_tif1_dataset(self) -> None:
        dlg = QFileDialog(self.dlg, self.tr("Select Image"))
        dlg.setMimeTypeFilters(['image/tiff', "application/octet-stream", 'image/png', 'image/jpeg'])
        if dlg.exec():
            path: str = dlg.selectedFiles()[0]
            layer = self.valid_exist_layer(path)
            if layer is None:
                layer = QgsRasterLayer(path, os.path.splitext(os.path.basename(path))[0])
                self.project.addMapLayer(layer)
                self.dlg.rDSACombo.setLayer(layer)

    def select_tif2_dataset(self) -> None:
        dlg = QFileDialog(self.dlg, self.tr("Select Post Image"))
        dlg.setMimeTypeFilters(['image/tiff', "application/octet-stream", 'image/png', 'image/jpeg'])
        if dlg.exec():
            path: str = dlg.selectedFiles()[0]
            layer = self.valid_exist_layer(path)
            if layer is None:
                layer = QgsRasterLayer(path, os.path.splitext(os.path.basename(path))[0])
                self.project.addMapLayer(layer)
                self.dlg.rDSBCombo.setLayer(layer)

    def select_vector_dataset(self) -> None:
        path, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select Label File", "", "*.shp;*.png;*.tif"
        )
        layer = self.valid_exist_layer(path)
        if os.path.exists(path):
            if layer is None:
                if ".shp" in path:
                    layer = QgsVectorLayer(path, os.path.splitext(os.path.basename(path))[0])
                else:
                    layer = QgsRasterLayer(path, os.path.splitext(os.path.basename(path))[0])
                self.project.addMapLayer(layer)
                self.dlg.vDSCombo.setLayer(layer)

    def select_mask_dataset(self) -> None:
        path, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Select ESRI Shpfiles", "", "*.shp"
        )
        layer = self.valid_exist_layer(path)
        if layer is None:
            layer = QgsVectorLayer(path, os.path.splitext(os.path.basename(path))[0])
            self.project.addMapLayer(layer)
            self.dlg.vDSMaskCombo.setLayer(layer)

    def alert(self, message: str, kind: str = 'information') -> None:
        """Display an interactive modal pop up.

        :param message: A text to display
        :param kind: The type of a pop-up to display; it is translated into a class method name of QMessageBox,
            so must be one of https://doc.qt.io/qt-5/qmessagebox.html#static-public-members
        """
        return getattr(QMessageBox, kind)(self.dlg, self.plugin_name, message)

    def push_message(self, message: str, level: Qgis.MessageLevel = Qgis.Info, duration: int = 5) -> None:
        """Display a message on the message bar.

        :param message: A text to display
        :param level: The type of a message to display
        :param duration: For how long the message will be displayed
        """
        self.iface.messageBar().pushMessage(config.PLUGIN_NAME, message, level, duration)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('RSDlTool', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/RsDlTool/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Rs DL Tool'),
                action)
            self.iface.removeToolBarIcon(action)

    def log(self, string):
        self.alert(self.tr("{}".format(string)))

    def batch_splitting(self) -> None:
        a_series_path = self.dlg.mQgsFileWidget_RA.filePath().split(" ")
        if self.dlg.useChangeCheck.isChecked():
            b_series_path = self.dlg.mQgsFileWidget_RB.filePath().split(" ")
        v_series_path = self.dlg.mQgsFileWidget_V.filePath().split(" ")

        # A = get_path_from_yaml(a_series_path)
        # B = get_path_from_yaml(b_series_path)
        # V = get_path_from_yaml(v_series_path)
        # self.log(a_series_path)

    def get_layer_path(self, mapLayerCombox):
        currentlayer = mapLayerCombox.currentText().split(" ")[0]
        rlayer = self.project.mapLayersByName(currentlayer)
        path = rlayer[0].dataProvider().dataSourceUri()
        return path

    def clip_raster_by_mask(self, a_ras_path, mkdir_p, mask_path=r''):
        # ------------------------- clip a with mask return tif_name
        temp_clip_dir_a = os.path.join(self.temp_dir, "processing_tfYpER", os.urandom(32).hex())
        mkdir_p(temp_clip_dir_a)
        temp_clip_name_a = os.path.join(temp_clip_dir_a, "OUTPUT.tif")
        params_a = {'INPUT': a_ras_path,
                    'MASK': mask_path, 'NODATA': None, 'ALPHA_BAND': False,
                    'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': True, 'OPTIONS': 'COMPRESS=LZW', 'DATA_TYPE': 0,
                    'OUTPUT': temp_clip_name_a}
        result = processing.run('gdal:cliprasterbymasklayer', params_a)
        return temp_clip_name_a

    def diag_spliting(self, a_ras_path, b_ras_path, vec_path, mask_path, datasetOutDir, classCfgPath,
                      SplittingBlockSize,
                      SplittingStrideSize, uniform_name, mkdir_p):
        currentrasterlayA = os.path.splitext(os.path.basename(a_ras_path))[0]
        if mask_path is not None:  # if b_ras_path vec_path classCfgPath mask_path
            if not os.path.exists(mask_path):
                self.alert(self.tr("mask layer doesn't exist"))
                return
            else:
                a_ras_path = self.clip_raster_by_mask(a_ras_path, mkdir_p, mask_path)
                b_ras_path = self.clip_raster_by_mask(b_ras_path, mkdir_p,
                                                      mask_path) if b_ras_path is not None else None

        dataset_paddle = datasetOutDir
        # dataset_paddle = os.path.join(datasetOutDir, "PaddlePaddle")
        mkdir_p(dataset_paddle)
        Ras_Paddle_path = os.path.join(dataset_paddle, "rasterized/")
        imageA_Paddle_path = os.path.join(dataset_paddle, "A/")
        imageB_Paddle_path = os.path.join(dataset_paddle, "B/")
        label_Paddle_path = os.path.join(dataset_paddle, "label/")
        muti_Lable_Paddle_path = os.path.join(dataset_paddle, "muti_label/")
        mkdir_p(Ras_Paddle_path)
        mkdir_p(imageA_Paddle_path)
        mkdir_p(imageB_Paddle_path)
        mkdir_p(label_Paddle_path)
        mkdir_p(muti_Lable_Paddle_path)

        # ----- raseterize binary
        if vec_path is not None:
            if 'shp' in vec_path:
                output = os.path.join(
                    Ras_Paddle_path, uniform_name + "_rasterized" + ".tif" if len(
                        uniform_name) > 0 else currentrasterlayA + "_rasterized" + ".tif"
                )  # Output Rasterized File
                rasterize(a_ras_path, vec_path, output)
            else:
                output = vec_path
                output = self.clip_raster_by_mask(output, mkdir_p, mask_path) if mask_path is not None else output
                if self.dlg.checkBoxMutiCls_2.isChecked():
                    self.alert(self.tr(" Rasterize Only Support SHPfile!"))
                    return
            if self.dlg.checkBoxSB.isChecked():
                self.iface.addRasterLayer(
                    output, uniform_name + "_rasterized" if len(
                        uniform_name) > 0 else currentrasterlayA + "_rasterized")
                self.iface.messageBar().pushMessage(
                    "You will find the rasterized file in " + output,
                    level=Qgis.Info,
                    duration=5,
                )

        # ----- raseterize  muticlass
        if classCfgPath is not None:
            if 'shp' not in vec_path:
                self.alert(self.tr("Rasterize Only Support SHPfile!"))
                return
            color_text_path = os.path.join(self.plugin_dir + "/utils/color.txt")
            class_cfg_path = classCfgPath
            outputRasIN = os.path.join(
                Ras_Paddle_path, uniform_name + "_1_255_rasterized" + ".tif" if len(
                    uniform_name) > 0 else currentrasterlayA + "_1_255_rasterized" + ".tif")
            InsSegGDALout = os.path.join(
                Ras_Paddle_path, uniform_name + "_muti_class_rasterized" + ".tif" if len(
                    uniform_name) > 0 else currentrasterlayA + "_muti_class_rasterized" + ".tif")
            rasterizeMutiCls(a_ras_path, vec_path, outputRasIN,
                             InsSegGDALout, color_text_path, class_cfg_path)

            if self.dlg.checkBoxMutiCls.isChecked():
                self.iface.addRasterLayer(
                    InsSegGDALout, uniform_name + "_muti_class_rasterized" if len(
                        uniform_name) > 0 else currentrasterlayA + "_muti_class_rasterized")
                self.iface.messageBar().pushMessage(
                    "You will find the rasterized file in " + InsSegGDALout,
                    level=Qgis.Info,
                    duration=5,
                )
        # --split pre-time image
        splitting(
            a_ras_path,
            imageA_Paddle_path,
            "jpg",
            "JPEG",
            "",
            SplittingBlockSize,
            SplittingStrideSize,
            uniform_name if len(uniform_name) > 0 else currentrasterlayA,
        )
        # --split post-time image
        if b_ras_path is not None:
            splitting(
                b_ras_path,
                imageB_Paddle_path,
                "jpg",
                "JPEG",
                "",
                SplittingBlockSize,
                SplittingStrideSize,
                uniform_name if len(uniform_name) > 0 else currentrasterlayA,
            )
        # --split binary label
        if vec_path is not None:
            splitting(
                output,
                label_Paddle_path,
                "png",
                "PNG",
                "",
                SplittingBlockSize,
                SplittingStrideSize,
                uniform_name if len(uniform_name) > 0 else currentrasterlayA,
            )  # should be the same name of image. vector name if needed-> currentvectorlay

        # --- spliting Multiclass Label
        if classCfgPath is not None:
            splitting(
                outputRasIN,
                muti_Lable_Paddle_path,
                "png",
                "PNG",
                "",
                SplittingBlockSize,
                SplittingStrideSize,
                uniform_name if len(uniform_name) > 0 else currentrasterlayA,
            )  # should be the same name of image. vector name if needed-> currentvectorlay

    #
    def create_splitting(self) -> None:
        def mkdir_p(path):
            if not os.path.exists(path):
                os.makedirs(path)

        a_series_path = self.dlg.mQgsFileWidget_RA.filePath()
        a_series_path = sorted(QgsFileWidget.splitFilePaths(a_series_path))
        b_series_path = self.dlg.mQgsFileWidget_RB.filePath()
        b_series_path = QgsFileWidget.splitFilePaths(b_series_path)
        v_series_path = self.dlg.mQgsFileWidget_V.filePath()
        v_series_path = QgsFileWidget.splitFilePaths(v_series_path)

        a_ras_path = self.get_layer_path(self.dlg.rDSACombo)
        b_ras_path = self.get_layer_path(self.dlg.rDSBCombo) if self.dlg.useChangeCheck.isChecked() else None
        vec_path = self.get_layer_path(self.dlg.vDSCombo) if self.dlg.checkBoxSB_2.isChecked() else None
        mask_path = self.get_layer_path(self.dlg.vDSMaskCombo) if self.dlg.checkBoxMask.isChecked() else None
        classCfgPath = self.dlg.mQfwDataset_ClassCfg.filePath() if self.dlg.checkBoxMutiCls_2.isChecked() else None

        # datasetOutDir = self.dlg.mQgsFileWidget_DatasetOut.lineEdit().text()
        datasetOutDir = self.dlg.mQgsFileWidget_DatasetOut.filePath()

        SplittingBlockSize = int(self.dlg.blockCombo.currentText())
        SplittingStrideSize = int(self.dlg.StrideCombo.currentText())
        uniform_name = self.dlg.lineEditUN.text()

        if not self.dlg.useBatchCheck.isChecked():
            self.diag_spliting(a_ras_path, b_ras_path, vec_path, mask_path, datasetOutDir, classCfgPath,
                               SplittingBlockSize, SplittingStrideSize, uniform_name, mkdir_p)
        else:
            if self.dlg.checkBoxSB_2.isChecked():
                if len(v_series_path) != len(a_series_path):
                    self.alert(self.tr("image: {},label:{} not equal".format(len(a_series_path), len(v_series_path))))
                    return
                for image, label in zip(a_series_path, v_series_path):
                    if "yml" in image or "yaml" in image:
                        A = get_path_from_yaml(image)
                        V = get_path_from_yaml(label)
                        if not len(A) == len(V):
                            self.alert(self.tr("image: {},label:{} not equal".format(len(A), len(V))))
                            return
                        for a, v in zip(A, V):
                            self.diag_spliting(a, None, v, mask_path, datasetOutDir, classCfgPath,
                                               SplittingBlockSize,
                                               SplittingStrideSize, uniform_name, mkdir_p)
                    else:
                        self.diag_spliting(image, None, label, mask_path, datasetOutDir, classCfgPath,
                                           SplittingBlockSize,
                                           SplittingStrideSize, uniform_name, mkdir_p)

            else:
                for image in a_series_path:
                    self.diag_spliting(image, None, None, mask_path, datasetOutDir, classCfgPath,
                                       SplittingBlockSize,
                                       SplittingStrideSize, uniform_name, mkdir_p)

            if self.dlg.useChangeCheck.isChecked():
                if len(b_series_path) != len(a_series_path):
                    self.alert(
                        self.tr("image: {},post-image:{} not equal".format(len(a_series_path), len(b_series_path))))
                    return
                for image, imageB, label in zip(a_series_path, b_series_path, v_series_path):
                    if "yml" in image or "yaml" in image:
                        A = get_path_from_yaml(image)
                        B = get_path_from_yaml(imageB)
                        V = get_path_from_yaml(label)
                        if not len(A) == len(V) == len(B):
                            self.alert(
                                self.tr("image: {},label:{},post image:{} not equal".format(len(A), len(V), len(B))))
                            return
                        for a, b, v in zip(A, B, V):
                            self.diag_spliting(a, b, v, mask_path, datasetOutDir, classCfgPath,
                                               SplittingBlockSize,
                                               SplittingStrideSize, uniform_name, mkdir_p)
                    else:
                        self.diag_spliting(image, imageB, label, mask_path, datasetOutDir, classCfgPath,
                                           SplittingBlockSize,
                                           SplittingStrideSize, uniform_name, mkdir_p)
        del_dir(os.path.join(datasetOutDir))
        self.alert(self.tr('Split Finished!'))

    #
    def create_splitting_v2(self):
        # Spin up a worker, a thread, and move the worker to the thread
        thread = QThread(self.iface.mainWindow())
        worker = SplittingCreator()
        worker.moveToThread(thread)
        # thread.started.connect(worker.create_processing)
        thread.started.connect(self.create_splitting_v2)
        worker.finished.connect(thread.quit)
        worker.error.connect(lambda error: self.log(error))
        worker.error.connect(
            lambda: self.alert(self.tr('Processing creation failed, see the QGIS log for details'), kind='critical'))
        self.dlg.finished.connect(thread.requestInterruption)
        thread.start()
        self.push_message(self.tr('Starting the processing...'))

    def dataset_maker(self):
        self.dlg.selectVDS.clicked.connect(self.select_vector_dataset)
        class_cfg_path = os.path.join(self.plugin_dir + "/utils/tblx.yaml")
        self.dlg.mQfwDataset_ClassCfg.lineEdit().setText(class_cfg_path)
        # -----开始运行
        self.dlg.startSplitting.clicked.connect(self.create_splitting)

    def init_inference(self):
        self.dlg.weightCombo.setCurrentIndex(0)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False

            self.project = QgsProject.instance()  # 用self.project 代替 QgsProject..instance()
            self.dlg = RSDlToolDialog()
            # Connect buttons
            self.dlg.selectRDSA.clicked.connect(self.select_tif1_dataset)
            self.dlg.selectRDSB.clicked.connect(self.select_tif2_dataset)
            self.dlg.selectVDSMask.clicked.connect(self.select_mask_dataset)
            self.dataset_maker()
            self.init_inference()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
